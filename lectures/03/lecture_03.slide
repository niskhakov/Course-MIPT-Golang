# Программирование на языке Go

Лекция 3. Составные типы. Ошибки

## Массивы

* Последовательность элементов определенного типа фиксированной длины (>=0)
* В основном используются слайсы, которые построены на массивах
* `[2]int` и `[3]int` - два разных типа. Размер должен быть константным выражением
* Поддерживаются операции доступа по индексу и итерация через `range`

		var a [3]int
		fmt.Println(a[0])
		fmt.Println(a[len(a)-1])
		for i, v := range a {...}

* Возможна инициализация через `{}`, в том числе с указанием индексов

		var q [3]int = [3]int{1, 2, 3}
		var p = [...]int{1, 2, 3}
		symbol := [...]string{USD: "$", EUR: "9", GBP: "!", RMB: """}
		fmt.Println(RMB, symbol[RMB])

## Массивы

* Если элементы массива сравнимы, то сравнимы и массивы
* Передача массива в функцию приводит к копированию всех элементов, что неэффективно для массивов большого размера

## Слайсы

* Последовательность элементов определенного типа изменяемой длины
* Данные на самом деле хранятся в массиве, который реаллоцируется при заполнении
* Фактически, это структура, хранящая указатель на массив, текущую длину и максимальную вместительность

		type slice struct {
			array unsafe.Pointer
			len   int
			cap   int
		}

		s := make([]int, 0, 3)
		len(s) // 0
		cap(s) // 3

* При передаче в функцию копируется структура `slice`, но указатель ссылается на те же данные.
Это приводит к набору спецэффектов, которые надо иметь ввиду

## Слайсы

* Несколько слайсов могут ссылать на один и тот же массив (т.е. изменение элемента через любой из
этих слайсов видно остальным)
* Оператор `[i:j]`, `0 <= i <= j <= cap(s)` создает новый слайс, который начинается с iго элемента
родительского слайса и имеет соотвествующие длину и capacity

		s := []int{0, 1, 2}
		s2 := s[1:]
		s2[0] = 3
		fmt.Println(s) // [0, 3, 2]

* Сабслайс с границей большей чем `cap(s)` приводит к панике, но с границей,
большей `len(s)` валидно (так что сабслайс может быть больше, чем исходный)
* Единственное валидное сравнение для слайса через `==` - сравнение с nil
* Слайс, инициализированный nil - валидный для добавления элементов слайс длины 0 и capacity 0.
Однако, обратное не верно - пустой слайс не то же самое, что nil

## append

* Встроенная функция `append` принимает слайс и элементы и возвращает новый слайс (т.е. `type slice`) с добавленными элементами в конце
* append может как вызвать реаллокацию исходного массива (и тогда исходный слайс и новый будут иметь под собой разные массивы),
так и возвращать новый слайс на основе того же массива
* Об этом надо всегда помнить, так как иначе можно получить неожиданное поведение

## append

		func appendInt(x []int, y int) []int {
			var z []int
			zlen := len(x) + 1
			if zlen <= cap(x) {
				// There is room to grow.  Extend the slice.
				z = x[:zlen]
			} else {
				// There is insufficient space.  Allocate a new array.
				// Grow by doubling, for amortized linear complexity.
				zcap := zlen
				if zcap < 2*len(x) {
					zcap = 2 * len(x)
				}
				z = make([]int, zlen, zcap)
				copy(z, x) // a built-in function; see text
			}
			z[len(x)] = y
			return z
		}

## In-Place операции

* Многие операции над слайсами (в основном фильтрацию) можно выполнить in-place, что будет эффективнее, чем аллоцировать
место под новые элементы

		var a = []int{0, 1, -1, 2, -2}
		filtered := a[:0] // len=0, cap=5
		for _, el := range a {
			if el > 0 {
				filtered = append(filtered, el)
			}
		}
		fmt.Println(filtered, len(filtered), cap(filtered)) // [1 2] 2 5
		fmt.Println(a, len(a), cap(a)) // [1 2 -1 2 -2] 5 5

## In-Place операции

* Для удаление элемента из начала или конца можно использовать `[i:j]`. При следующей реаллокации
"забытые" элементы не копируются

		func push(q []int, el int) []int {
			return append(q, el)
		}

		func pop(q []int) []int {
			return q[1:]
		}

		var q []int // [] 0 0
		q = push(q, 1) // [1] 1 1
		q = push(q, 2) // [1 2] 2 2
		q = pop(q) // [2] 1 1
		q = push(q, 3) // [2 3] 2 2

## Другие операции над слайсами

* Удаление и вставка в середину - дорогая операция

		var a = []int{0, 1, 3, 5}
		a = append(a[:2+1], a[2:]...)
		a[2] = 2
		fmt.Println(a) // [0 1 2 3 5]

		var a = []int{0, 1, 2, 3, 5}
		a = append(a[:2], a[3:]...)
		fmt.Println(a) // [0 1 3 5]

## Ассоциативные массивы (maps)

* Unordered ассоциативный массив на основе hash-таблицы
* Аналогично слайсам, map - структура, хранящая указатели данные
* Однако, операции над map более инкапсулированы

		type hmap struct {
    	// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.
    	// Make sure this stays in sync with the compiler's definition.
    	count     int // # live cells == size of map.  Must be first (used by len() builtin)
    	flags     uint8
    	B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)
    	noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details
    	hash0     uint32 // hash seed

    	buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.
    	oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing
    	nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)

    	extra *mapextra // optional fields
    }

## Maps

* Ключ должен быть сравним через оператор `==` (однако, использовать в качестве ключа `float` типы зачастую плохая идея)
* Для использования map необходимо инициализировать через `make` или `{}`. В противном случае при попытке вставить элемент
будет panic (в отличии от слайсов, где nil - валидный слайс)

		var m = make(map[string]int)
		var m2 = map[string]int{
			"one": 1,
		}

* map можно сравнивать (==) с nil
* При обращении к несуществующему элементу будет возвращено zero value и (необязательный) флаг наличия элемента

		one := m["one"]
		one, ok := m["one"]

* Для удаления элемента из map есть встроенная функция delete

## Maps

* С элементами map можно производить операции как с обычными переменными, за исключением того, что
от элемента нельзя взять адрес

		_ = &ages["bob"] // compile error: cannot take address of map element

* Для итерации можно использовать `for range`

		for name, age := range ages {
			fmt.Printf("%s\t%d\n", name, age)
		}

* Порядок элементов не определен, если необходим отсортированный результат - придется
складывать элементы в слайс и сортировать его
* В Go нет типа set, поэтому используется map вместо него

	var set map[string]bool
	var set2 map[string]struct{} // struct{} - empty type

## Структуры

* Объединение нескольких именованных перменных (полей) различных типов
* Доступ до различных элементов - через `.`

		type Employee struct {
			ID        int
			Name      string
		}
		var dilbert Employee
		dilbert.ID = 1

* Можно брать указатели на отдельные поля
* Неявное разыменование - отсутствует оператор `->`

		var ptr = &dilbert
		ptr.ID = 2
		(*ptr).ID = 3

* Обычно поля объявляются по одному на строку, но можно объединять поля одного типа (как в `var`)
* Первая бука поля (заглавная или нет) определяет видимость этого поля из других пакетов

## Структуры

* Zero value для структуры - комбинация zero values его полей
* Обычно, если у пакета нет функции `NewSmth` для типа `Smth`, то валидно использовать zero value этого типа
* `struct{}` - пустая структура размера 0 (иногда используется в map)
* Структура может быть инициализирована через `{}` с указанием имен полей и без (не рекомендуется)

		type Point { X, Y int }
		var p = Point{1, 2}
		var p2 = Point{X: 1, Y: 2}
		var p3 = Point{Y: 2, X: 1}
		var p4 = Point{Y: 2} // X = zero value

* Зачастую используются указатели на структуры, при инициализации можно сразу получить указатель

		var ptr = &Point{}

* Если все поля структуры сравнимы, то и структуру можно сравнивать с использованием `==` и `!=`

## Embedding

* "Своеобразное" наследование, позволяет указать другую структуру анонимным полем и обращаться через `.` напрямую к полям (и методам) анонимного поля

		type Circle struct {
				Point // Point Point
				Radius int
		}
		var c = Circle{Point:  Point{1, 2}, Radius: 0}
		c.X = 0
		c.Point.Y = 0

* Нельзя иметь два анонимных поля одного типа
* Видимость анонимного поля определяется видимостью имени типа (но сокращения через `.` все равно продолжат работать)
* Если возникает конфликт по именам полей двух или более анонимных полей, то краткая форма через `.` недоступна
* К полям можно навешивать тэги, которые используются некоторыми библиотеками (например, json)

## Функции

		func name(parameter-list) (result-list) {
				body
		}

* Функция может принимать >= 0 аргументов и возвращать >= 0 значений
* Обычно аргументам даются имена (однако, можно их опускать или называть `_`) и редко даются имена
возвращаемым значениями (в основном, когда из типов сразу не ясно, что возвращается)
* При именованных возвращаемых значениях при входе в функцию они - обычные переменные. Можно использовать
`return` без указания возвращаемых значений, и вернутся значения из этих переменных

## Функции

* Функции можно использовать как одругие типы - записывать в переменные, передавать в аргументах и т.д. (они first-class values)
* Однако, следует помнить, что переменные вне скоупа функции захватываются "по ссылке"
* Например, нельзя захватывать переменные в цикле:

		var rmdirs []func()
		for _, d := range tempDirs() {
			dir := d               // NOTE: necessary!
			os.MkdirAll(dir, 0755) // creates parent directories too
			rmdirs = append(rmdirs, func() {
				os.RemoveAll(dir)
			})g
		}

## Ошибки

* Все ошибки возвращаются явным образом с типом встроенного интерфейса `error` (исключение - panic, о нем отдельно)

		type error interface {
        Error() string
    }

* Можно создавать ошибки различных типов, главное, чтобы они удовлетворяли интерфейсу
* Ошибки можно сравнивать с nil и между собой (устаревший вариант, после go 1.13 для сравнения используются `errors.Is` и `errors.As`)
* Метод `errors.Unwrap` вызывает соответствующий метод у типа, если он определен, либо возвращает nil

## Ошибки

* Ошибки могут оборачивать одна другую: `fmt.Errorf("failed: %w", ErrNotFound)`
* `errors.Is` - в цепочке ошибок есть ошибка-переменная (`var ErrNotFound = errors.New("not found")`)
* `errors.As` - в цепочке ошибок есть ошибки с нужным типом