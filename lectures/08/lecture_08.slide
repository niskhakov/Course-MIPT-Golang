# Программирование на языке Go

Лекция 8. Reflection

## Reflection

* Рефлексия — способность программы исследовать собственную структуру, в особенности через типы.
Это форма метапрограммирования и отличный источник путаницы. (c) [Законы рефлексии в Gо](https://habr.com/ru/post/415171/)
* Пригождается, когда необходимо реализовать обобщенную функцию, про аргументы которой мы ничего не знаем

## Fprintf

* Типичный пример - `fmt.Fprintf`. Эта функция умеет форматировать почти любые входные данные (в том
числе типы, объявленные пользователем)
* Для вывода значений мы можем использовать type switch, однако мы будем ограничены конечным набором типов
(а еще надо уметь форматировать слайсы и словари любых типов и любой вложенности)

		type stringer interface {
			 String() string
		}
		switch x := x.(type) {
		case stringer:
			 return x.String()
		case string:
			 return x
		case int:
			 return strconv.Itoa(x)
		// ...similar cases for int16, uint32, and so on...

* Для реализации задуманного нам надо уметь заглядывать в структуру неизвестных заранее нам типов

## reflect.Type

* Один из двух основных типов пакета `reflect`
* `Type` представляет некоторый тип в Go и позволяет узнавать многое о том, как этот тип устроен
(какие есть поля, аргументы функций, ...)
* Функция `TypeOf` принимает `interface{}` и возвращает `Type` для переданного аргумента

		t := reflect.TypeOf(3)  // a reflect.Type
		fmt.Println(t.String()) // "int"
		fmt.Println(t)          // "int"

* Стоит учитывать, что `TypeOf` всегда возвращает динамический тип (т.е. в случае передачи интерфейса будет
возвращена информация о конкретном типе, не о интерфейсе)

		var w io.Writer = os.Stdout
		fmt.Println(reflect.TypeOf(w)) // "*os.File"

* Для дебага бывает удобно использовать `%T` в `Printf`, который внутри использует `reflect.TypeOf`

## reflect.Value

* Второй основной тип пакета `reflect`
* `Value` может хранить любое значение любого типа
* `ValueOf` принимает `interface{}` и возвращает `Value`, содержащий значение
* Результат `ValueOf` всегда конкретный, но может также содержать значение интерфейса

		v := reflect.ValueOf(3) // a reflect.Value
		fmt.Println(v)          // "3"
		fmt.Printf("%v\n", v)   // "3"
		fmt.Println(v.String()) // NOTE: "<int Value>"

* По `Value` получить обратно `interface{}` со значением можно с помощью метода `reflect.Value.Interface`
* Разница между `interface{}` и `reflect.Value` заключается в том, что без знания конкретного типа
мы не можем толком ничего сделать с `interface{}` (т.к. мы можем использовать только type assertion). `reflect.Value`
же позволяет изучать содержание, ничего не зная о типе

## reflect.Value

* Метод `Kind` позволяет получить значение перечисления, чем является данное значение
* Для массивов и слайсов (и для строк): `Len` и `Index`
* Для структур: `NumField` и `Field` (включая встроенные и сокрытые)
* Для словарей: `MapKeys` и `MapIndex`
* Для указателей: `IsNil` и `Elem`
* Для интерфейсов: `IsNil` и `Elem`

## reflect.Value

* Кроме доступа до данных, `Value` позволяет также изменять их
* Однако, изменять можно только значения с адресом (можно проверить через `CanAddr`)
* Кроме этого, нельзя изменять неэкспортированные поля структур
* В общем случае, проверить, можно ли менять значение можно через `CanSet`

## Тэги

* Ранее мы использовали тэги при работе с `encoding/json`. Данный механизм применяется в большом количестве
пакетов и позволяет указывать дополнительную инофрмацию как надо обрабатывать то или иное поле структуры
* Получить тэг для поля можно через поле `Tag` у `reflect.Type`
* Далее получить интересующее нас значение можно через `Get`

## Reflection

* В ситуациях, где это возможно, старайтесь избегать использование reflection
* Использование reflections сильно замедляет код (см., например, [easyjson](https://github.com/mailru/easyjson))
* Очень легко допустить ошибку (например, не предусмотреть возможные входные параметры) при написании кода с reflection
* Нужно максимально проверять возможность операций перед их выполнением (иначе вылетит паника)
* Кроме этого, использование reflection сильно затрудняет возможности автоматическим анализаторам и программам
для рефакторинга