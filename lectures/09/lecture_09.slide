# Программирование на языке Go

Лекция 9. Низкоуровневое программирование

## Низкоуровневое программирование

* Го предоставляет некоторый набор гарантий по "безопасности" программы
* Большое количество проверок происходит как на этапе компиляции, так и в рантайме
* Множество "внутренностей" скрыто от разработчиков за абстракциями
* Эти гарантии и сокрытия, с одной стороны, позволяют не допускать критических ошибок и слабо зависеть
от архитектуры и ОС, но с другой стороны ограничивают возможности программистов
* До очень многих вещей невозможно дотянуться (организация памяти, машинный код функций, системные потоки)
* Однако, пакет `unsafe` позволяет "спуститься уровнем ниже" и достичь большей производительности
за счет снятия некоторых ограничений

## Низкоуровневое программирование

* Однако, использовать возможности низкоуровневого программирования надо с очень большой осторожностью
* Без должного внимания к деталям и понимания работы низкоуровневых вещей легко допустить ошибки,
которые могут приводить к самым неожиданным последствиям (как в C/C++)

## Unsafe

* `unsafe.Sizeof` возвращает размер в байтах результата выражения (любого типа), при этом само выражение
не вызывается
* Вызов `unsafe.Sizeof` на самом деле - константное выражение типа `uintptr`, и может использоваться, например
для размера массива и т.п.
* `unsafe.Alignof` возвращает требуемое смещение для типа выражения (это тоже константное выражение)
*`unsafe.Offsetof` возвращает смещение поля в структуре

## Unsafe

* `unsafe.Pointer` - специальный указатель, который может хранить адрес на любой объект
* `unsafe.Pointer` может быть взять из любого указателя (`*T`) и сконвертирован в любой указатель
(не обязательно того же типа)
* `unsafe.Pointer` может быть преобразован в адрес типа `uintptr` и обратно
* При этом очень плохая идея создавать временную переменную для преобразованного адреса в `uintptr` -
сборщик мусора может в любой момент перекроить распределение объектов по адресному пространству (или
даже подчистить объект) и в этом случае адрес станет невалидным (но фактически вряд ли)

## Unsafe

* С помощью `unsafe` можно получить низкоуровневый контроль над памятью (точнее, над объектами в памяти)
* Это позволяет, например, производить операции, которые запрещены на уровне "простого Go"
* Такие операции позволяют существенно ускорить некоторые операции (например, избежать копирования данных
при конвертациях строк в слайс байтов и обратно)
* Однако, если можно обойтись "простым Go", то лучше всего пожертвовать производительностью в пользу
более контролируемого и предсказуемого поведения
* Одно маленькое неочевидное неучтенное что-то может привести к абсолютно непредсказуемым последствиям
* Более того, все "фишки" языка (например, GC), начинают играть против вас

## Cgo

* Даже в современных реалиях C (ну и C++) остается "наиболее распространенным" языком
* Вероятно, для любой функциональности можно найти библиотеку на C/C++, которая ее реализует (но это не точно)
* Cgo позволяет использовать такие библиотеки внутри Go программ. Это было особенно полезно на начальных
этапах, когда pure go библиотек было не так много
* Более того, даже стандартные простые программы могут использовать Cgo (например, использующие сетевой стек
под линуксом)
* Можно включать или выключать поддержку Cgo переменной окружения CGO_ENABLED (1 - включено, 0 - выключено)
* По умолчанию Cgo включен для нативной сборки под текущую платформу и выключен для кросс-компиляции

## Cgo

* Пакет может содержать различные имплементации в зависимости от того включен ли Cgo или нет
([и не только](https://golang.org/cmd/go/#hdr-Build_constraints))
* Можно, например, сделать Cgo имплементацию и пустую pure go имплементацию для того, чтобы IDE находила
нужные объекты

## Cgo

* Однако, Cgo привносит очень много проблем:
	* Замедление времени сборки
	* Трудности при кросс-компиляции
	* Требуется ручное управление памятью
	* Сам по себе вызов C из Go не бесплатен
	* Появляется зависимость от C-библиотек и компилятора
	* Многие гошные интрументы перестают работать (например, pprof)
	* При вызове лочится весь системный тред (и более того, может создаваться множество системных тредов
	под эти нужды)
	* C-код даже не подозревает, что существует какой-то go с его горутинами, асинхронщиной и т.п.
* [The Cost and Complexity of Cgo](https://www.cockroachlabs.com/blog/the-cost-and-complexity-of-cgo/)

## Cgo

* В случае, когда причины использовать Cgo перевешивают недостатки, тулчейн go предоставляет возможность
сгенерировать "границу" между C и Go
* Кроме этого, есть [SWIG](https://swig.org), предоставляющий больше возможностей по биндингу C/C++
* Для того, чтобы использовать Cgo, необходимо подключить "фиктивный" пакет `import "C"`, добавив в коментариях
необходимую метаинформацию
* Сущности из C станут доступны через пакет "C" - он будет сгенерирован на ходу на основе анализа исходных
кодов на "C" (почти всегда - заголовочных файлов)
* Обычно между библиотекой и Go-кодом добавляется прослойка для более удобного использования (например,
возможность объединять работу, чтобы не создавать много Cgo-вызовов, а сделать все в одном)